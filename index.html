<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pixel Scene — Clima & Personaje (Mike/Susan)</title>
<style>
  :root{
    --bg: #000;
    --panel-bg: rgba(0,0,0,0.45);
    --panel-fg: #fff;
    --muted: rgba(255,255,255,0.06);
    --accent: #6fc3ff;
  }
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Segoe UI,Roboto;color:var(--panel-fg)}
  .app { display:flex; gap:18px; align-items:flex-start; padding:18px; }

  /* CANVAS WRAPPER */
  #container{ position:relative; display:inline-block; border-radius:8px; overflow:visible }
  canvas{ image-rendering: pixelated; border:4px solid #444; background:#88ccee; display:block; }

  /* UI column (fuera del canvas) */
  .ui { width: 340px; display:flex; flex-direction:column; gap:12px; }
  .card { background: var(--panel-bg); border-radius:10px; padding:10px; border:1px solid var(--muted); backdrop-filter: blur(6px); }
  .row { display:flex; gap:8px; align-items:center; justify-content:space-between; }
  .title { font-weight:600; margin-bottom:6px; }
  .small { font-size:13px; color:#ddd; }

  /* Buttons */
  .btn { background: transparent; border: 1px solid var(--muted); color: var(--panel-fg); padding:8px 10px; border-radius:8px; cursor:pointer; }
  .btn.primary { background: rgba(255,255,255,0.07); }
  .btn.small { padding:6px 8px; font-size:13px; }

  /* Character selector (outside canvas) */
  .characters { display:flex; gap:8px; }
  .char-btn { padding:8px 12px; border-radius:8px; background:transparent; border:1px solid var(--muted); cursor:pointer; color:var(--panel-fg); }
  .char-btn.active { background: rgba(255,255,255,0.08); }

  .hint { font-size:12px; color:#cfcfcf; opacity:0.9; text-align:center; }
  #weatherBadge { font-weight:600; }

  /* SEARCH RESULTS */
  #searchResults { margin-top:8px; display:flex; flex-direction:column; gap:6px; max-height:180px; overflow:auto; }
  .result {
    display:flex; align-items:center; justify-content:space-between;
    padding:8px; border-radius:8px; background: rgba(255,255,255,0.02);
    border:1px solid rgba(255,255,255,0.03); cursor:pointer;
  }
  .result:hover, .result:focus { outline: none; box-shadow: 0 0 0 2px rgba(111,195,255,0.12); background: rgba(111,195,255,0.03); }
  .result .label { font-size:13px; }
  .result .sub { font-size:12px; color:#cfcfcf; }

  .muted { color:#bbb; font-size:13px; }

  @media (max-width:900px){
    .ui { width: 92%; max-width:420px; }
    .app { flex-direction:column; align-items:center; }
  }
</style>
</head>
<body>
  <div class="app">
    <!-- Canvas area -->
    <div id="container" aria-label="Escenario pixel art">
      <canvas id="game" role="img" aria-label="Escena pixelada"></canvas>
      <button id="fsBtn" title="Pantalla completa" style="position:absolute; top:8px; right:8px; width:36px; height:36px; border-radius:8px; background:var(--panel-bg); border:1px solid var(--muted); display:grid; place-items:center; cursor:pointer;">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="#fff"><path id="fsPath" d="M7 14H5v4h4v-2H7v-2zm10 6h-4v2h6v-6h-2v4zM5 4v6h2V6h2V4H5zm12 0v2h2v2h2V4h-4z"/></svg>
      </button>
    </div>

    <!-- Controls outside the canvas -->
    <div class="ui" aria-label="Panel de controles">
      <!-- Time card -->
      <div class="card" id="timeCard">
        <div class="title">Hora</div>
        <div class="row">
          <div style="font-size:18px;font-weight:700" id="localTime">--:--:--</div>
          <div style="font-size:13px;color:#bbb" id="timePeriod">—</div>
        </div>
        <div style="margin-top:8px" class="small">Zona: <span id="tzName">Local</span></div>
        <div style="margin-top:8px" class="small hint">La escena se ajusta según la hora y el clima de la ciudad seleccionada.</div>
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button id="resetLocal" class="btn small">Restablecer a local</button>
        </div>
      </div>

      <!-- Weather & location -->
      <div class="card">
        <div class="title">Clima</div>
        <div id="weatherBadge">Detectando clima…</div>

        <div style="margin-top:10px; display:flex; gap:8px;">
          <button id="allowLoc" class="btn small primary">Permitir ubicación</button>
          <button id="retryLoc" class="btn small">Reintentar</button>
        </div>

        <div style="margin-top:10px;">
          <label class="small">Buscar ciudad (manual)</label>
          <div style="display:flex; gap:8px; margin-top:6px;">
            <input id="cityInput" placeholder="Bogotá, Madrid..." style="flex:1;padding:8px;border-radius:8px;border:1px solid var(--muted);background:transparent;color:var(--panel-fg)" aria-label="Buscar ciudad">
            <button id="searchCity" class="btn small">Buscar</button>
          </div>
          <div id="locStatus" class="small" style="margin-top:8px;color:#ccc">Estado: esperando</div>

          <!-- search results list -->
          <div id="searchResults" aria-live="polite" aria-label="Resultados de búsqueda"></div>
        </div>
      </div>

      <!-- Character selection -->
      <div class="card">
        <div class="title">Personaje</div>
        <div class="characters" role="radiogroup" aria-label="Elegir personaje">
          <button id="btnMike" class="char-btn active" role="radio" aria-checked="true">Mike</button>
          <button id="btnSusan" class="char-btn" role="radio" aria-checked="false">Susan</button>
        </div>
        <div class="small hint" style="margin-top:8px">Cambia el personaje en cualquier momento.</div>
      </div>

      <div class="card">
        <div class="title">Consejo</div>
        <div class="small">Si niegas ubicación, usa la búsqueda manual por ciudad. Selecciona la coincidencia correcta de la lista.</div>
      </div>
    </div>
  </div>

<script>
/* ========== CONFIG ========== */
const LOGICAL = 64;
const DEFAULT_SCALE = 4;
let SCALE = DEFAULT_SCALE;
const canvas = document.getElementById('game');
const container = document.getElementById('container');
const ctx = canvas.getContext('2d');

function applyCanvasSize(){
  const px = LOGICAL * SCALE;
  canvas.width = px; canvas.height = px;
  canvas.style.width = px + 'px'; canvas.style.height = px + 'px';
  ctx.imageSmoothingEnabled = false;
}
applyCanvasSize();

/* ========== STATE ========== */
let frame = 0;
let action = 'idle';
let actionTime = 0;
let dir = 1;
let posX = 20;
const groundY = 44;
let jumpOffset = 0, armOffset = 0, legOffset = 0, scratchOffset = 0;

const clouds = [
  { x: 4, y:8, speed:0.02, w:12 },
  { x: 30, y:6, speed:0.03, w:14 },
  { x: 50, y:10, speed:0.018, w:10 }
];

let weather = { kind: 'unknown', temp: null, desc: '—' };
let rainDrops = [], snowFlakes = [], fogAlpha = 0;
let character = 'mike';

/* timezone & place handling */
let browserTZ = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
let currentTimezone = browserTZ;
let currentLocationName = 'Local';

/* UI refs */
const weatherBadge = document.getElementById('weatherBadge');
const allowLoc = document.getElementById('allowLoc');
const retryLoc = document.getElementById('retryLoc');
const cityInput = document.getElementById('cityInput');
const searchCity = document.getElementById('searchCity');
const locStatus = document.getElementById('locStatus');
const searchResults = document.getElementById('searchResults');
const btnMike = document.getElementById('btnMike');
const btnSusan = document.getElementById('btnSusan');
const localTimeEl = document.getElementById('localTime');
const timePeriodEl = document.getElementById('timePeriod');
const tzNameEl = document.getElementById('tzName');
const resetLocalBtn = document.getElementById('resetLocal');
const fsBtn = document.getElementById('fsBtn');
const fsPath = document.getElementById('fsPath');

/* ======= UTIL: map weather codes (Open-Meteo) ======= */
function mapWeatherCode(code){
  if(code === 0) return 'clear';
  if(code === 1 || code === 2) return 'partly';
  if(code === 3) return 'cloudy';
  if([45,48].includes(code)) return 'fog';
  if([51,53,55,56,57].includes(code)) return 'drizzle';
  if([61,63,65,66,67,80,81,82].includes(code)) return 'rain';
  if([71,73,75,77,85,86].includes(code)) return 'snow';
  if([95,96,99].includes(code)) return 'thunder';
  return 'unknown';
}

/* ======= Fetch weather using Open-Meteo (timezone=auto) ======= */
async function fetchWeatherAt(lat, lon, placeNameOpt){
  try {
    const placeLabel = placeNameOpt || 'Local';
    locStatus.textContent = `Ubicación: ${placeLabel} (${lat.toFixed(3)}, ${lon.toFixed(3)})`;
    weatherBadge.textContent = 'Obteniendo clima…';
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=auto`;
    const r = await fetch(url);
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
    if(j && j.current_weather){
      const cw = j.current_weather;
      const kind = mapWeatherCode(cw.weathercode);
      weather = { kind, temp: cw.temperature, desc: cw.weathercode };
      if(j.timezone) currentTimezone = j.timezone;
      currentLocationName = placeNameOpt || (j.timezone || 'Local');
      updateWeatherEffects();
      updateBadge();
      updateTimeDisplay();
      // clear results after selection
      renderSearchResults([]);
    } else {
      weather = { kind:'unknown', temp:null, desc:'—' };
      updateBadge();
    }
  } catch(e){
    console.error(e);
    locStatus.textContent = 'Error al obtener clima.';
    weatherBadge.textContent = 'Clima: error';
  }
}

/* ======= Geolocation request ======= */
function requestLocationAndWeather(){
  if(!navigator.geolocation){
    weatherBadge.textContent = 'Geolocalización no soportada';
    locStatus.textContent = 'Geolocalización no soportada';
    return;
  }
  locStatus.textContent = 'Solicitando ubicación…';
  weatherBadge.textContent = 'Solicitando ubicación…';
  navigator.geolocation.getCurrentPosition(async pos => {
    const { latitude, longitude } = pos.coords;
    currentLocationName = 'Local';
    await fetchWeatherAt(latitude, longitude, currentLocationName);
  }, err => {
    console.warn(err);
    locStatus.textContent = 'Ubicación denegada o fallida.';
    weatherBadge.textContent = 'Ubicación denegada — usa búsqueda manual';
  }, { timeout: 10000 });
}

/* ======= Geocoding by city (return multiple matches) ======= */
async function geocodeCity(name){
  try {
    locStatus.textContent = 'Buscando ciudad…';
    weatherBadge.textContent = 'Buscando…';
    // request up to 10 matches
    const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=10`;
    const r = await fetch(url);
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
    if(j && j.results && j.results.length){
      // render all results and let user pick
      renderSearchResults(j.results);
      weatherBadge.textContent = `Se encontraron ${j.results.length} coincidencias`;
      locStatus.textContent = 'Selecciona la ciudad correcta de la lista.';
    } else {
      renderSearchResults([]);
      locStatus.textContent = 'Ciudad no encontrada.';
      weatherBadge.textContent = 'Ciudad no encontrada';
    }
  } catch(e){
    console.error(e);
    locStatus.textContent = 'Error búsqueda ciudad';
    weatherBadge.textContent = 'Error búsqueda';
  }
}

/* ======= Render search results list (clickable & keyboard) ======= */
function renderSearchResults(results){
  searchResults.innerHTML = '';
  if(!results || results.length === 0){
    return;
  }
  results.forEach((res, idx) => {
    const div = document.createElement('div');
    div.className = 'result';
    div.tabIndex = 0;
    const label = document.createElement('div');
    label.className = 'label';
    // build nice label: "City, admin1, country"
    const admin = res.admin1 ? (', ' + res.admin1) : '';
    label.textContent = `${res.name}${admin}, ${res.country}`;
    const sub = document.createElement('div');
    sub.className = 'sub muted';
    // include lat/lon and population if available
    const pop = res.population ? ` — pop ${res.population}` : '';
    sub.textContent = `Lat ${res.latitude.toFixed(3)}, Lon ${res.longitude.toFixed(3)}${pop}`;
    const right = document.createElement('div');
    right.style.marginLeft = '8px';
    right.innerHTML = '<button class="btn small" aria-label="Seleccionar">Elegir</button>';
    div.appendChild(label);
    div.appendChild(sub);
    div.appendChild(right);

    // click handler: when user picks this city, fetch weather for its coords and set place label
    const pick = async () => {
      const placeLabel = `${res.name}${res.admin1 ? ', '+res.admin1 : ''}${res.country ? ', '+res.country : ''}`;
      // set UI feedback
      locStatus.textContent = `Seleccionado: ${placeLabel}`;
      weatherBadge.textContent = `Obteniendo clima para ${placeLabel}…`;
      await fetchWeatherAt(res.latitude, res.longitude, placeLabel);
    };

    div.addEventListener('click', pick);
    div.addEventListener('keydown', (ev) => {
      if(ev.key === 'Enter' || ev.key === ' '){
        ev.preventDefault();
        pick();
      }
    });

    searchResults.appendChild(div);
  });
}

/* ======= Update weather effects ======= */
function updateWeatherEffects(){
  rainDrops = []; snowFlakes = []; fogAlpha = 0;
  switch(weather.kind){
    case 'rain':
    case 'drizzle':
    case 'thunder':
      for(let i=0;i<160;i++){
        rainDrops.push({ x: Math.random()*LOGICAL, y: Math.random()*LOGICAL, l: 1 + Math.random()*2, speed: 0.8 + Math.random()*1.6 });
      }
      break;
    case 'snow':
      for(let i=0;i<120;i++){
        snowFlakes.push({ x: Math.random()*LOGICAL, y: Math.random()*LOGICAL, r: 0.7 + Math.random()*1.6, speed: 0.2 + Math.random()*0.7 });
      }
      break;
    case 'fog':
      fogAlpha = 0.28;
      break;
    default:
      break;
  }
}

/* ======= Time helpers (Intl timezone aware) ======= */
function getTimePartsForTimezone(tz){
  try {
    const fmt = new Intl.DateTimeFormat('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false, timeZone: tz });
    const parts = fmt.formatToParts(new Date());
    const obj = { hour:0, minute:0, second:0 };
    for(const p of parts){
      if(p.type === 'hour') obj.hour = parseInt(p.value,10);
      if(p.type === 'minute') obj.minute = parseInt(p.value,10);
      if(p.type === 'second') obj.second = parseInt(p.value,10);
    }
    return obj;
  } catch(e){
    const now = new Date();
    return { hour: now.getHours(), minute: now.getMinutes(), second: now.getSeconds() };
  }
}

function getHourFloat(tz){
  const p = getTimePartsForTimezone(tz);
  return p.hour + p.minute/60 + p.second/3600;
}

function getTimeOfDay(tz = currentTimezone){
  const h = getTimePartsForTimezone(tz).hour;
  if(h >= 6 && h < 12) return 'morning';
  if(h >= 12 && h < 18) return 'afternoon';
  if(h >= 18 && h < 21) return 'evening';
  return 'night';
}

function computeSunMoonPos(tz = currentTimezone){
  const hourFloat = getHourFloat(tz);
  let t, x, y;
  if(hourFloat >= 6 && hourFloat <= 18){
    t = (hourFloat - 6) / 12;
    x = 6 + t*(LOGICAL-12);
    y = 6 + Math.sin(t*Math.PI)*10;
    return { sun:true, x, y };
  } else {
    let hh = hourFloat; if(hh < 6) hh += 24;
    t = (hh - 18) / 12;
    x = 6 + t*(LOGICAL-12);
    y = 6 + Math.sin(t*Math.PI)*10;
    return { sun:false, x, y };
  }
}

/* ======= Drawing routines (kept) ======= */
/* drawBackground, drawCloud, drawTree, drawGround, drawCharacter, drawRain, updateRain, drawSnow, updateSnow, drawFog, updateAction, loop, drawStarsForNight */
function drawBackground(timeOfDay){
  if(timeOfDay === 'morning') ctx.fillStyle = '#bfefff';
  else if(timeOfDay === 'afternoon') ctx.fillStyle = '#9fe3ff';
  else if(timeOfDay === 'evening') ctx.fillStyle = '#ffb86b';
  else ctx.fillStyle = '#07122a';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(timeOfDay === 'evening'){
    ctx.save();
    const bandH = canvas.height/6;
    ctx.fillStyle = '#ffd89b'; ctx.fillRect(0,0,canvas.width,bandH);
    ctx.fillStyle = '#ffb86b'; ctx.fillRect(0,bandH,canvas.width,bandH*2);
    ctx.fillStyle = '#9b67d3'; ctx.fillRect(0,bandH*3,canvas.width,bandH*3);
    ctx.restore();
  }

  const pos = computeSunMoonPos(currentTimezone);
  ctx.save(); ctx.scale(SCALE,SCALE);
  if(pos.sun){
    ctx.fillStyle = '#FFF3A6'; ctx.fillRect(Math.round(pos.x)-1,Math.round(pos.y)-1,8,8);
    ctx.fillStyle = '#FFD24D'; ctx.fillRect(Math.round(pos.x),Math.round(pos.y),6,6);
  } else {
    ctx.fillStyle = '#f7f9ff'; ctx.fillRect(Math.round(pos.x),Math.round(pos.y),6,6);
    ctx.fillStyle = (timeOfDay === 'night') ? '#07122a' : '#9b67d3';
    ctx.fillRect(Math.round(pos.x)+2,Math.round(pos.y)+1,3,3);
  }
  ctx.restore();
}

function drawCloud(cx, cy, w, timeOfDay){
  ctx.save(); ctx.scale(SCALE,SCALE);
  ctx.fillStyle = (timeOfDay === 'night') ? 'rgba(255,255,255,0.12)' : '#ffffff';
  ctx.fillRect(cx, cy+1, w-2, 2);
  ctx.fillRect(cx+1, cy, w-4, 2);
  ctx.fillRect(cx+Math.floor(w/2)-1, cy-1, 3, 2);
  ctx.restore();
}

function drawTree(timeOfDay){
  ctx.save(); ctx.scale(SCALE,SCALE);
  ctx.fillStyle = (timeOfDay === 'night') ? '#472b16' : '#6b3b1a';
  ctx.fillRect(3, groundY - 8, 2, 6);
  ctx.fillStyle = (timeOfDay === 'night') ? '#1f3f1f' : '#2e8b2e';
  ctx.fillRect(0, groundY - 14, 8, 3);
  ctx.fillRect(1, groundY - 17, 6, 3);
  ctx.fillRect(2, groundY - 19, 4, 2);
  ctx.fillStyle = (timeOfDay === 'night') ? '#2c5e2c' : '#57b957';
  ctx.fillRect(4, groundY - 16, 2, 1);
  ctx.restore();
}

function drawGround(timeOfDay){
  ctx.save(); ctx.scale(SCALE,SCALE);
  ctx.fillStyle = (timeOfDay === 'night') ? '#334d36' : '#7bc36a';
  ctx.fillRect(0, groundY, LOGICAL, LOGICAL - groundY);
  ctx.fillStyle = (timeOfDay === 'night') ? '#2a3f2b' : '#5fa854';
  ctx.fillRect(0, groundY + 4, LOGICAL, LOGICAL - (groundY+4));
  ctx.restore();
}

function drawCharacter(px, py, timeOfDay){
  ctx.save(); ctx.scale(SCALE,SCALE); ctx.translate(px, py - jumpOffset);
  ctx.fillStyle = (timeOfDay === 'night') ? 'rgba(0,0,0,0.18)' : 'rgba(0,0,0,0.12)';
  ctx.fillRect(12,26,8,1);
  ctx.fillStyle = '#FFD27F'; ctx.fillRect(12,4,8,8);

  if(character === 'mike'){
    ctx.fillStyle = (timeOfDay === 'night') ? '#1f2439' : '#2a2f4a';
    ctx.fillRect(12,4,8,2);
  } else {
    ctx.fillStyle = (timeOfDay === 'night') ? '#2b1f35' : '#6b2b6b';
    ctx.fillRect(11,4,10,2);
    ctx.fillRect(11,6,1,4);
  }

  ctx.fillStyle = '#000';
  if(!(action === 'blink' && Math.floor(frame/10)%2 === 0)){
    ctx.fillRect(14,6,1,1); ctx.fillRect(17,6,1,1);
  }
  ctx.fillStyle = '#9b3a3a'; ctx.fillRect(15,9,2,1);

  if(character === 'mike'){
    ctx.fillStyle = (timeOfDay === 'night') ? '#25407a' : '#3366cc';
    ctx.fillRect(10,12,12,8);
    ctx.fillStyle = (timeOfDay === 'night') ? '#213560' : '#2b55a1';
    ctx.fillRect(12,14,8,4);
  } else {
    ctx.fillStyle = (timeOfDay === 'night') ? '#7a3a5a' : '#ff77bb';
    ctx.fillRect(10,12,12,8);
    ctx.fillStyle = (timeOfDay === 'night') ? '#5a2a43' : '#d64b95';
    ctx.fillRect(12,14,8,4);
  }

  ctx.fillStyle = '#FFD27F';
  ctx.fillRect(8,12+Math.round(armOffset),2,6);
  if(action === 'scratch') ctx.fillRect(22,8+Math.round(scratchOffset),2,6);
  else ctx.fillRect(22,12-Math.round(armOffset),2,6);

  ctx.fillStyle = (timeOfDay === 'night') ? '#2b2b2b' : '#444';
  ctx.fillRect(12,20-Math.round(legOffset),3,6);
  ctx.fillRect(17,20+Math.round(legOffset),3,6);
  ctx.fillStyle = '#111'; ctx.fillRect(12,25,3,1); ctx.fillRect(17,25,3,1);
  ctx.restore();
}

function drawRain(){ ctx.save(); ctx.scale(SCALE,SCALE); ctx.fillStyle='rgba(180,210,255,0.85)'; for(const r of rainDrops) ctx.fillRect(Math.round(r.x),Math.round(r.y),1,Math.ceil(r.l)); ctx.restore(); }
function updateRain(){ for(const r of rainDrops){ r.y += r.speed; r.x -= 0.1; if(r.y > LOGICAL+2){ r.y = -2; r.x = Math.random()*LOGICAL; } } }
function drawSnow(){ ctx.save(); ctx.scale(SCALE,SCALE); ctx.fillStyle='rgba(255,255,255,0.95)'; for(const s of snowFlakes) ctx.fillRect(Math.round(s.x),Math.round(s.y),Math.ceil(s.r),Math.ceil(s.r)); ctx.restore(); }
function updateSnow(){ for(const s of snowFlakes){ s.y += s.speed; s.x += Math.sin(frame/30 + s.x)*0.1; if(s.y > LOGICAL+2){ s.y = -2; s.x = Math.random()*LOGICAL; } } }
function drawFog(){ if(fogAlpha <=0) return; ctx.save(); ctx.globalAlpha = fogAlpha; ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); }

function updateAction(){ const actions=['idle','walk','blink','scratch','jump']; action=actions[Math.floor(Math.random()*actions.length)]; actionTime=60+Math.floor(Math.random()*90); if(action==='walk'&&Math.random()>0.6)dir*=-1; }

/* stars */
const stars = (()=>{ const a=[]; for(let i=0;i<60;i++) a.push({ x: Math.random()*(LOGICAL-6)+3, y: Math.random()*(groundY-20)+2, r: Math.random()>0.85?1.5:1 }); return a; })();
function drawStarsForNight(){ ctx.save(); ctx.scale(SCALE,SCALE); ctx.fillStyle='#ffffff'; for(const s of stars) ctx.fillRect(Math.round(s.x), Math.round(s.y), s.r, s.r); ctx.restore(); }

/* ======= update UI time display using currentTimezone ======= */
function updateTimeDisplay(){
  const parts = getTimePartsForTimezone(currentTimezone);
  const hh = String(parts.hour).padStart(2,'0');
  const mm = String(parts.minute).padStart(2,'0');
  const ss = String(parts.second).padStart(2,'0');
  localTimeEl.textContent = `${hh}:${mm}:${ss}`;
  const period = getTimeOfDay(currentTimezone);
  timePeriodEl.textContent = period.charAt(0).toUpperCase()+period.slice(1);
  tzNameEl.textContent = currentLocationName + (currentTimezone ? (' — ' + currentTimezone) : '');
}
setInterval(updateTimeDisplay, 1000);
updateTimeDisplay();

/* ======= Main loop ======= */
function loop(){
  frame++;
  const timeOfDay = getTimeOfDay(currentTimezone);

  for(const c of clouds){ c.x += c.speed * (timeOfDay === 'night' ? 0.6 : 1); if(c.x > LOGICAL + c.w) c.x = -c.w - 2; }

  if(actionTime > 0) actionTime--; else updateAction();

  if(action === 'walk'){ posX += 0.12 * dir; armOffset = Math.sin(frame/6)*1.2; legOffset = Math.sin(frame/6)*1.6; } else { armOffset = 0; legOffset = 0; }
  scratchOffset = (action === 'scratch')? Math.sin(frame/4)*2 : 0;
  jumpOffset = (action === 'jump')? Math.abs(Math.sin(frame/6)*4)*(Math.sin(frame/6)>0?1:0) : 0;

  const leftLimit = 6, rightLimit = LOGICAL - 20;
  if(posX < leftLimit){ posX = leftLimit; dir = 1; }
  if(posX > rightLimit){ posX = rightLimit; dir = -1; }

  if(rainDrops.length) updateRain();
  if(snowFlakes.length) updateSnow();

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground(timeOfDay);

  if(timeOfDay === 'night') drawStarsForNight();
  else if(timeOfDay === 'evening'){ ctx.save(); ctx.globalAlpha = 0.25; drawStarsForNight(); ctx.restore(); }

  for(const c of clouds) drawCloud(Math.round(c.x), Math.round(c.y), c.w, timeOfDay);
  drawTree(timeOfDay);
  drawGround(timeOfDay);

  if(rainDrops.length) drawRain();
  if(snowFlakes.length) drawSnow();
  if(fogAlpha > 0) drawFog();

  drawCharacter(Math.round(posX), groundY - 28, timeOfDay);

  requestAnimationFrame(loop);
}

/* ======= Fullscreen handling ======= */
function computeScaleForFullscreen(){ const maxW = window.innerWidth, maxH = window.innerHeight; return Math.max(1, Math.floor(Math.min(maxW/LOGICAL, maxH/LOGICAL))); }
function enterFullscreen(){ if(container.requestFullscreen) container.requestFullscreen(); else if(container.webkitRequestFullscreen) container.webkitRequestFullscreen(); }
function exitFullscreen(){ if(document.exitFullscreen) document.exitFullscreen(); else if(document.webkitExitFullscreen) document.webkitExitFullscreen(); }
fsBtn.addEventListener('click', ()=>{ if(!document.fullscreenElement && !document.webkitFullscreenElement) enterFullscreen(); else exitFullscreen(); });
function updateFullscreenState(){ const isFS = !!(document.fullscreenElement || document.webkitFullscreenElement); if(isFS){ fsPath.setAttribute('d','M5 14H3v6h6v-2H5v-4zm14 6h-6v2h8v-8h-2v6zM3 4v8h2V6h4V4H3zm14 0v2h4v4h2V4h-6z'); SCALE = computeScaleForFullscreen(); } else { fsPath.setAttribute('d','M7 14H5v4h4v-2H7v-2zm10 6h-4v2h6v-6h-2v4zM5 4v6h2V6h2V4H5zm12 0v2h2v2h2V4h-4z'); SCALE = DEFAULT_SCALE; } applyCanvasSize(); }
document.addEventListener('fullscreenchange', updateFullscreenState); document.addEventListener('webkitfullscreenchange', updateFullscreenState);
window.addEventListener('resize', ()=>{ if(document.fullscreenElement || document.webkitFullscreenElement){ SCALE = computeScaleForFullscreen(); applyCanvasSize(); } });

/* ======= UI events ======= */
allowLoc.addEventListener('click', ()=> { requestLocationAndWeather(); });
retryLoc.addEventListener('click', ()=> { requestLocationAndWeather(); });
searchCity.addEventListener('click', ()=> {
  const name = cityInput.value.trim();
  if(!name){ locStatus.textContent = 'Escribe una ciudad.'; return; }
  geocodeCity(name);
});
cityInput.addEventListener('keydown', (e)=> {
  if(e.key === 'Enter') searchCity.click();
});

/* reset local uses browser TZ and tries to re-request geolocation weather */
resetLocalBtn.addEventListener('click', ()=>{
  currentTimezone = browserTZ;
  currentLocationName = 'Local';
  tzNameEl.textContent = currentLocationName + ' — ' + currentTimezone;
  requestLocationAndWeather();
});

/* character selection */
btnMike.addEventListener('click', ()=> { character = 'mike'; btnMike.classList.add('active'); btnSusan.classList.remove('active'); btnMike.setAttribute('aria-checked','true'); btnSusan.setAttribute('aria-checked','false'); });
btnSusan.addEventListener('click', ()=> { character = 'susan'; btnSusan.classList.add('active'); btnMike.classList.remove('active'); btnSusan.setAttribute('aria-checked','true'); btnMike.setAttribute('aria-checked','false'); });

/* ======= init ======= */
requestLocationAndWeather();
updateAction();
loop();
/* keep badge and effects updated when weather changes */
setInterval(()=> { if(weather.kind){ updateWeatherEffects(); updateBadge(); } }, 2500);

</script>
</body>
</html>
